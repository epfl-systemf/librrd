2025-09-01
==========

todo
 * bigger library of presets
 * decide whether to switch to Typeable properties
 * global wrapping
 * make negative stacks sometimes have vertical tips

broader
 * wrapping experiments
 * finish redoing the paper
 * see how bad it is in ECOOP template

done
 * fix left-recursive child and descendant thing, allow multiple
 * font family, style, weight, size as layout properties
 * investigate passing backend around as an implicit parameter
   + no: I want to statically know it's the same one for the whole structure
 * read align-self, and make it sided
 * small library of presets
 * reasonable local wrapping for demo


2025-08-19
==========

todo
 * read align-self, and make it sided
 * small library of presets
 * decide whether to switch to Typeable properties
 * global wrapping
 * make negative stacks sometimes have vertical tips
 * reasonable local wrapping for demo

broader
 * wrapping experiments
 * finish redoing the paper
 * see how bad it is in ECOOP template

done
 * fix left-recursive child and descendant thing, allow multiple
 * font family, style, weight, size as layout properties
 * investigate passing backend around as an implicit parameter
   + no: I want to statically know it's the same one for the whole structure


2025-08-15
==========

todo
 * read align-self, and make it sided
 * font family, style, weight, size as layout properties
 * small library of presets
 * fix left-recursive child and descendant thing, allow multiple
 * decide whether to switch to Typeable properties
 * investigate passing backend around as an implicit parameter
 * global wrapping
 * make negative stacks sometimes have vertical tips
 * reasonable local wrapping for demo

broader
 * wrapping experiments
 * finish redoing the paper
 * see how bad it is in ECOOP template


2025-04-09
==========

stacks do not need to know nesting to flex.
a containing stack gives its non-vertical-tip-stack subdiagrams less of the available width
  (absorbing some for itself per flex-absorb),
  and its vertical-tip-stack subdiagrams the full available width, which they can further distribute.

what if a - has + top?

2025-02-25
==========

still TBD about finishing behavior

what is a parameter vs. a global constant vs. an argument?
-> some of them depend on each other

still need to draw curves

2025-02-20
==========

I guess still TBD about finishing behavior.

decided that flex distr will be arith (others don't make sense)

TODOs
* animate width with constant speed, see what arith vs quad distr looks like
* come up with paper outline
* draw curves??
* global optimum should be calculated based on align-items
  + actually doesn't affect any of the parameters

From weekly update:

> Regardless of the form, I think global optimality depends on the following
> properties of wraps:
> * the natural width (must be less than requested, and doesn’t matter too much
>   beyond that);
> * the height (smaller is better); and
> * the global wrap specifications, i.e. where line breaks have happened, at
>   each nested level (fewer is better, and outer is better than inner, so there
>   is another degree of freedom here in choosing how those two combine).
>
> A local wrapping decision depends on:
> * the min-content width (must be less than requested, and beyond that ?);
> * the max-content width (?? I guess the difference between the requested width
>   and the min- and max-content widths is a proxy for height, which we cannot
>   directly measure in an unwrapped diagram, and for which smaller is better);
>   and
> * the local wrap specifications (fewer is better).

2025-02-11
==========

fixed bugs identified yesterday.
still tbd about finishing behavior.
today: play with optimality.

2025-02-10
==========

bugs with nested recursion. try
    ((<> - "a" (<> + (<> - "b" "c") "d")))

1. not enough space for mandatory arrows
2. need to disambiguate the inner recursion "c" from the outer option "d". extra space

control the finishing behavior with a parameter

2025-02-06
==========

why allow for aligning the boxes and then choosing tips?
  aligning boxes looks unnatural, outside the schema I have for RRDs

today's work sets up for tomorrow:
* align-items policies beyond physical-0
* refine global optimality definition
* think about the TODO about physical tips for block layout

later, leave space for curves. should be simple now that widths depend on requested tips everywhere.

2025-02-05
==========

currently: choose tips (default ones), then align "pulled taut"
todo:
* choose non-default tips (and then align as usual). which ones? top, mid, bot?
* align first (start center end ?), then choose tips that minimize (avoid?) curviness
* sequences have more than one tip on either side: curvy connectors
  so atoms have only one tip, same height both sides;
  and seqs & stacks have continuous tips, each side indep.
  consistent

possible factors of optimality
* height
* natural width
* number of wraps, total or each level weighted
  (inner worse than outer)
* compactness


2025-01-29
==========

among equal heights, smallest max-content ?

choosing between wraps, some function of max-content and height, not separable

min(h, mcw)

TODO: is there a situation in which h-w curve is not monotonic

2025-01-22
==========

drew arrows today
text-box does not have its own tips; rather, station lays out as an happend with hstruts
  also fixes horizontal alignment of arrows
but! vappend has its own tips because the shape depends on internals
  (cannot attach later)
  plus, arrows would not be out of alignment if the tips are curved and hence "off-limits"

every diagram needs a -content-v and a -content-h for whether you request v or h tips
is too much layout computation happening at the diagram level?
all layouts make a tip distinction and need to know their tips

2025-01-21
==========

a "fully wrapped" diagram is one where min-content == max-content,
i.e. there are no wrapping decisions remaining.

should a wrapped sequence contain regular components with their own min- and max-contents,
  and thus itself have a range?
  and thus itself allocate space per the algorithm below while the original sequence only
    picks between different self wraps based on the min- and max-contents?
or should a wrapped sequence only contain fully wrapped components,
  and thus itself be fully wrapped?
  and thus the original sequence picks between different self wraps as well as different
    sub wraps?

"local is better"!

big remaining to-do is to figure out what an "align-items" policy for sequences means. reminder that unlike flexbox, align-items for us is not just vertical positioning of the subdiagrams in a sequence but also choosing tips on each side of each subdiagram (with possibly curved connectors in between).

small remaining to-do is to draw curves and arrows instead of this brutalist version

2025-01-20
==========

why is flex-grow not proportional to the item's size?
* and instead, is relative
* the closest you can get is "flex-basis: auto; flex-grow: 1;"

assumption: if (lay-out w1) produces pw1 <= w1,
  then (lay-out w2) for w2 > w1 will produce pw2 <= w2
maybe also: pw1 <= pw2 (monotonic)
maybe also: (lay-out w) if w <= min-content produces pw = min-content,
  else min-content <= pw <= w

for compiling an n-ary choice expression to binary stacks,
the outer one has to be non-flex, inners flex

wrapped sequence given a width
available width for EACH ROW is
  (max (given width - markers?) (self min-content - markers?))
   - gaps (depends on length of row)
for EACH ROW:
  give each sub its min-content (+ struts for stacks)
  left over space = available - sum of above
  absorb per extra-space-absorb
  left over space = (1-esa) * ...
  distribute weighted by ALL max-contents to only NONFLEX subs
    clamp nonflex subs to max-content
  left over space = + excess
  distribute weighted by FLEX max-contents to FLEX subs
  justify left over space
    (exactly what was extra-space-absorbed, unless there are no flex subs)

is the above the only algorithm that makes sense?

2025-01-16
==========

things that are similar to flex:

is it concerning that I am reimplementing some of flex and other CSS?

2025-01-14
==========

Trying to load all this back into working memory. The problem I was working on was about sequences and wrapping decisions. I don’t remember all the details of the discussions I had with Clément, but a few key points:

* A sequence has a plain list of subs; a sequence that has made a wrapping decision has a list of lists of subs, each outer list corresponding to one row, such that the concatenation of all the lists is the original list of subs.
  + Equivalently, a wrapping decision is a list of indices in the subs list after which to break. The number of possible wraps is thus 2**(n-1).

* A wrapped sequence has a min-content width below which it cannot be laid out. It also has a max-content width above which it can be laid out, but a lower-cost wrap of the same sequence could also be laid out. (Cost depends on number of rows and total height (which depends also on the chosen tips for the subdiagrams). Cost does not depend on any widths. Rather, you choose the lowest-cost wrap whose min-content width is less than the desired width.)
  + This isn’t right. The max-content width shouldn’t depend on other wraps.
  + Should it depend on the energy of the subdiagams that may have also wrapped?

local decisions. don’t go up and down the structure for every layout.
the way flex does this is with flex-basis, defaulting to the max-content.
but flex can only achieve the two extremes: inner wraps first and outer wraps first. can’t do a mix? what about with percentage widths? -> you’ll always get the same *number* of subs on each row!

want to minimize jumping around i.e. rewrapping. so when forced to wrap, choose one that will be good for as long as possible.
  can I encode that in the cost?
  not just "minimize height while staying under requested width" but also ?

assume you had perfect information and no computational constraints. how do you find the optimum?
  what is perfect information?
    for every sequence (all the way down), list of all break points and corresponding min-content widths ("min-width: auto;" for a flex item is min-content) and heights
    to calculate min-content width, start from leaves and just add (right?)
  then some function of (width difference to next relayout, height)
    equivalently (min-content width, height)
    Pareto frontier of non-dominating options

there’s no good reason to not prioritize height, i.e. to jump to a narrower layout when not needed. how often are we going to progressively shrink and grow these diagrams anyway?

scenario:
  given width 100
  attempt to lay out subs at 50, 20, 30
  50 and 20 manage; 30 reports 35
  --> should ask 50 and 20 to compensate! proportional to weight again?
  repeat until either everyone has hit limit or achieve goal


2024-11-12
==========

(Refresher.      At the diagram level, we have the following constructors:
* Atomic
  + Station = box with text
  + Epsilon = nothing, but can be drawn as a horizontal line if needed
* Composite
  + Stack = place one diagram on top of another; "polarity" indicates whether they go in the same or opposite directions
  + Sequence = string one or more diagrams together horizontally

Diagrams do not have an inherent direction, width, etc.; those are parameters for laying out a diagram. A composite diagram is responsible for laying out its subdiagrams and composing those layouts according to layout policies. The only policy that matters for a stack is "justify-content": how to distribute extra horizontal space in each row. A sequence additionally depends on "align-items", i.e. how to vertically align its subdiagrams, and a policy that I cannot succinctly name/describe, which is the subject of this update.)

Sequences can wrap to fit in narrower widths than if their subdiagrams were simply laid out side-by-side. This week, I am trying to precisely characterize the wrapping decisions that a sequence (containing diagrams that may also be sequences or contain sequences, and so on at all levels of nesting) has to make. Some initial observations/questions follow.

For any sequence, there is always a width *W* such that the sequence can be laid out at any width >= W without wrapping itself or any of its nested sequence subdiagrams. At each level of nesting, some of the extra space will be absorbed by the sequence by spacing out its subdiagrams, and the rest will be taken up by the subdiagrams. But how do we avoid absorbing too much space and forcing a subdiagram to wrap when that could have been avoided?

Why should RRDs be any different from CSS flexbox?




LESS OLD
========

diagram
* can call lay-out on its children possibly multiple times
* tries to satisfy a requested width and tips
* lay-out method depends on layout parameters: min-strut-width, align-items, justify-content

layout
* in terms of physical rows, connections, materialized tips
* can report physical height and width
* "trivial" translation into rendering depending on rendering parameters: font, pens
   + (new rendering% [pen (cur-pen)] ...) etc. and then the rendering will set that pen for itself and every rendering will initialize its pens
   +
* hierarchy:
   + atom
   + happend
      - with horizontal strut info
   + vappend
      - with brackets, eventually curved joints
      - sometimes the brackets are only on one side for wrapping

rendering
* basically a sequence of instructions
* paths, not segments that happen to join! hence: one rendering for the box of an atom (and maybe its text), and one for the happend layout that contains all the ones in a row
* (to be sent to a canvas with a given offset, or HTML, or serialized, etc.)


OLD
===

* seqs are turned into inline diagrams, choices and loops into block
  diagrams, stations into atomic block diagrams, holes into atomics
  with width as needed to match corresponding recursive component
  + what if we had left and right coördinates instead of width?
  + actually, start and end. and width = sgn(direction)*(end - start)

* diagram can be inline or block
  + both types
    - have children of any type
    - expose method (min-width) = (max (map min-width children)) + C
    - expose method (lay-out max-width) that produces the corresponding
      layout type or fails
  + inline
    - optionally: recursively splices inline children, i.e. treats
      inline children as own children
    - lay-out first does lay-out of all children at either:
      i. (outer squeeze) (- max-width C)
      ii. (inner squeeze) their own min-widths
      and then follows a line-breaking strategy (e.g. greedy) to assign
      them to rows, either boustrophedon or CRLF, with per-row space
      distribution strategy, connecting sequentially, to build an
      **inline layout**
  + block
    - atomic block diagram (for stations) has pre-specified layout
    - otherwise, lay-out does lay-out of all children at (- max-width
      C) and then assigns each to a row to build a **block layout**

* layout can be inline or block
  + both types
      - have height (lines), width (pixels), entry & exit line & direction
      - have children of any type
      - have rows, each with a height
      - each child has a row
      - height of a row = max(height of children on that row)
      - height = sum(heights of rows)
      - width of a row = sum(width of children on that row)
      - width = max(widths of rows)
      - expose methods (connect-to other), (draw! x y)
  + inline layout
      - always enters on (relative) first line and exits on last
      - entry & exit direction independent
      - connect-to is a larger inline layout as described on whiteboard
      - can be converted to block by flushing first and last rows
  + block layout
      - entry & exit line independent, but must be respectively the
        entry/exit line of a child
        = of a row
      - entry & exit direction always the same
      - each row has exactly one child
      - connect-to block is a larger block layout (intuitive),
        connect-to inline is inline

* drawing
  + somehow has to preserve information from way before about nodes so
    they can be drawn to the dc and connected with lines with curves
  + set and reset origin
